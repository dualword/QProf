/***************************************************************************
                          parseprofile_pose.cpp  -  description
                             -------------------
    begin                : Jul 05 2012
    copyright            : (C) 2012 by Eduard Kalinowski
    email                : eduard_kalinowski@yahoo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program == free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
#include "./includes/parseprofile_callgrind.h"

#include <stdlib.h>

#include "./includes/parseprofile.h"
#include "./includes/cprofileinfo.h"
#include "./includes/qprofwidget.h"

#include <assert.h>
#include <QTextStream>
#include <QVector>
#include <QString>
#include <QStringList>
#include <QDebug>
#include <QRegExp>
#include <QHash>

CParseProfile_callgrind::CParseProfile_callgrind (QTextStream& strm, QVector<CProfileInfo>& profile)
{
    /*
     * parse a profile results file generated by the PalmOS Emulator
     *
     */

    int numEntries = 0;
    int cgCount = 0;
    QString s;
    linenr = 0;

    strm.setCodec ("Latin1");

//     callGraphBlock.resize (32);

    CProfileInfo *rootFunc;
    CProfileInfo *subFunc;
//     int lines = 0;
    bool hasIdInfo = false;
    unsigned long samplFunc;
    unsigned long samplSubFunc;
//     bool scanSubF;



    while (!strm.atEnd()) {
        line =  strm.readLine();
        line = line.simplified();
        linenr++;
//         if (linenr > 1000)
//             break;

        if (line.length() == 0) {
            if (hasIdInfo == false)
                continue;

//             func = findFunction(profile, actualFuncId);
            if (rootFunc == NULL) {
                continue;
            }
//             rootFunc = NULL;
            subFunc = NULL;
            //func->custom.callgrind.cumSamples = func->custom.callgrind.selfSamples;
//             for(int i=0; i<func->numCalls.count(); i++) {
//                 func->custom.callgrind.cumSamples += (func->numCalls[i] * func->called[i]->custom.callgrind.selfSamples);
//             }
//             processCallGraphBlock (callGraphBlock, profile);
//             callGraphBlock.resize (0);
            cleanPointers(profile);

            continue;
        }

        char c = line.at(0).toLatin1();

        if (!c) {
            continue;
        }

        if (c <= '9') {
            if (c == '#') {
                continue;
            }

//             func = findFunction(profile, actualFuncId);
            if (rootFunc == NULL) {
                continue;
            }

            QString num;
            bool io;

            int pos = line.lastIndexOf(" ");
            if (pos > 0 )
                num = line .mid(pos+1);
            else
                continue;

            samplFunc = num.toULong(&io);
            if (io == false) {
                qDebug() << QString("Invalid line '%1'").arg(line);
                continue;
            }

            if (subFunc == NULL) {
                rootFunc->custom.callgrind.cumSamples += samplFunc;
            }
            else {
                subFunc->custom.callgrind.cumSamples += samplFunc;
            }
            // go through after big switch
        } else {
            switch(c) {
            case 'f':
                subFunc = NULL;
                cleanPointers(profile);
                // fl=, fi=, fe=
                if (line.startsWith("fl=") || line.startsWith("fi=") || line.startsWith("fe=")) {
                    int pos = line.indexOf(" ");
                    actualFileId = extractId(line);
                    actualCalledFileId = actualFileId;

                    if (pos > 0) {
                        if (fileName.find(actualFileId) == fileName.end()) {// not exististing
                            fileName.insert(actualFileId, line.mid( pos + 1));
                        }
                    }

                    continue;
                }

                // fn=
                if (line.startsWith("fn=")) {
                    int pos = line.indexOf(QRegExp("[\\t\\s]"));
                    actualFuncId = extractId(line);
                    if (actualFuncId == -1) continue;

                    if (pos > 0) {
                        if (function.find(actualFuncId) == function.end()) { // not exististing
                            QString nm=line.mid( pos + 1);
                            if (nm.length() >0) {
                                function.insert(actualFuncId, nm);
//                                 qDebug() << nm << actualFuncId;
                            }
                        }
                    }

                    rootFunc = make_function(profile);


                    if (rootFunc == NULL) {
                        continue;
                    }
                    hasIdInfo = true;

#if 0
                    // on a new function, update status
                    int progress = (int)(100.0 * file.current() / file.len() + .5);

                    if (progress != statusProgress) {
                        statusProgress = progress;

                        /* When this signal is connected, it most probably
                         * should lead to GUI update. Thus, when multiple
                         * "long operations" (like file loading) are in progress,
                         * this can temporarly switch to another operation.
                         */
                        loadProgress(statusProgress);
                    }

#endif
                    continue;
                }

                break;

            case 'c':
                // cob=
                if (line.startsWith("cob=")) {
                    int pos = line.indexOf(" ");
                    actualCalledLibId = extractId(line);
                    if (pos > 0) {
                        if (libName.find(actualCalledLibId) == libName.end()) // not exististing
                            libName.insert(actualCalledLibId, line.mid( pos + 1));
                    }
                    continue;
                }

                // cfi= / cfl=
                if (line.startsWith("cfl=") || line.startsWith("cfi=")) {
                    int pos = line.indexOf(" ");
                    actualCalledFileId = extractId(line);
                    if (pos > 0) {
                        if (fileName.find(actualCalledFileId) == fileName.end()) // not exististing
                            fileName.insert(actualCalledFileId, line.mid( pos + 1));
                    }
                    continue;
                }

                // cfn=
                if (line.startsWith("cfn=")) {
                    int pos = line.indexOf(QRegExp("[\\t\\s]"));
                    actualCalledFuncId = extractId(line);
                    if (actualCalledFuncId == -1) continue;
//                    if (actualCalledFuncId== 1760)qDebug() << line << pos;

                    if (pos > 0) {
                        if (function.find(actualCalledFuncId) == function.end()) { // not exististing
                            QString nm=line.mid( pos + 1);
                            if (nm.length() >0) {
                                function.insert(actualCalledFuncId, nm);
//                                 qDebug() << nm << actualCalledFuncId;
                            }
                        }
                    }

                    subFunc = make_CalledFunction(profile);

                    continue;
                }

                // calls=
                if (line.startsWith("calls=")) {
                    CProfileInfo *tfunc;
                    long int callNum = 0;
                    // ignore long lines...
//                     line.stripUInt64(currentCallCount);
                    tfunc = findFunction(profile, actualFuncId);
                    if (tfunc != NULL) {
                        CProfileInfo* cf;
                        cf = findFunction(profile, actualCalledFuncId);
//                         if (cf==NULL) qDebug() << line << actualCalledFuncId;
                        QString num;
                        int pos = line.indexOf("=");
                        if (pos > 0) {
                            int posSpace =line.indexOf(" ", pos + 1);
                            if (posSpace > 1)
                                num = line.mid(pos + 1, posSpace-pos-1);
                            else
                                num = line.mid(pos + 1);

                            callNum = num.toULongLong();
//
                            for (int i= 0; i <tfunc->called.count(); i++) {

                                if (tfunc->called.at(i)->name == function[actualCalledFuncId]) {
//                                     qDebug() << "called func id: "<< actualCalledFuncId << "calls" << num << "called" << func->called.at(i)->name;
                                    tfunc->numCalls[i] = callNum;
                                    tfunc->called.at(i)->calls = callNum;
                                }
                            }
                        }
                    }
                    tfunc = findFunction(profile, actualCalledFuncId);
                    if (tfunc != NULL) {
                        tfunc->calls += callNum;
                    }
                    continue;
                }

                // cmd:
                if (line.startsWith("cmd:")) {
                    QString command = QString(line).trimmed();
                    continue;
                }

                // creator:
                if (line.startsWith("creator:")) {
                    // ignore ...
                    continue;
                }

                break;

            case 'j':
                // jcnd=
                if (line.startsWith("jcnd=")) {
                    bool valid;
                    continue;
                }

                if (line.startsWith("jump=")) {
                    bool valid;
                    continue;
                }

                // jfi=
                if (line.startsWith("jfi=")) {
                    continue;
                }

                // jfn=
                if (line.startsWith("jfn=")) {
                    continue;
                }

                break;

            case 'o':
                // ob=
                if (line.startsWith("ob=")) {
                    int pos = line.indexOf(" ");
                    actualLibId = extractId(line);

                    actualCalledLibId = actualLibId;
                    if (pos > 0) {
                        if (libName.find(actualLibId) == libName.end()) // not exististing
                            libName.insert(actualLibId, line.mid( pos + 1));
                    }

                    continue;
                }

                break;

            case '#':
                continue;

            case 't':
                // totals:
                if (line.startsWith("totals:")) {
                    continue;
                }

                // thread:
                if (line.startsWith("thread:")) {
                    continue;
                }

                // timeframe (BB):
                if (line.startsWith("timeframe (BB):")) {
                    continue;
                }

                break;

            case 'd':
                // desc:
                if (line.startsWith("desc:")) {
                    continue;
                }

                break;

            case 'e':
                // events:
                if (line.startsWith("events:")) {
                    continue;
                }

                // event:<name>[=<formula>][:<long name>]
                if (line.startsWith("event:")) {
                    continue;
                }

                break;

            case 'p':
                // part:
                if (line.startsWith("part:")) {
                    continue;
                }

                // pid:
                if (line.startsWith("pid:")) {
                    continue;
                }

                // positions:
                if (line.startsWith("positions:")) {
                    continue;
                }

                break;

            case 'v':
                // version:
                if (line.startsWith("version:")) {
                    // ignore for now
                    continue;
                }

                break;

            case 's':
                // summary:
                if (line.startsWith("summary:")) {
                    QString num;
                    num = line.mid(line.indexOf(" ") + 1);
                    summary =  num.toLongLong();

                    continue;
                }

            case 'r':
                // rcalls= (deprecated)
                if (line.startsWith("rcalls=")) {
                    // ignored
                    // handle like normal calls: we need the sum of call count
                    // recursive cost is discarded in cycle detection
//                     line.stripUInt64(currentCallCount);
//                     nextLineType = CallCost;
//
//                     warning(QString("Old file format using deprecated 'rcalls'"));
                    continue;
                }

                break;

            default:
                break;
            }

//             qDebug() << QString("Invalid line '%1'").arg(line);
//             continue;
        }

        if (rootFunc == NULL)
            continue;
    }

    cleanPointers(profile);

    recalculate(profile);

//     processCallGraphBlock (callGraphBlock, profile);
//     callGraphBlock.resize(0);
//     return true;

}

void CParseProfile_callgrind::recalculate( QVector<CProfileInfo>& profile) {
    for(QVector<CProfileInfo>::iterator iPr = profile.begin(); iPr != profile.end(); ++iPr) {
        if ((*iPr).calls != 0) {
            (*iPr).custom.callgrind.selfSamples = (*iPr).custom.callgrind.cumSamples / (*iPr).calls;
        }
        if (summary > 0) {
            (*iPr).cumPercent = (*iPr).custom.callgrind.cumSamples / (float)summary;
            (*iPr).selfSeconds = (*iPr).custom.callgrind.selfSamples / (float)summary;
            for(int i=0; i< (*iPr).called.count(); ++i) {
                if ((*iPr).called.at(i)->calls != 0) {
                    (*iPr).called.at(i)->cumPercent = (*iPr).called.at(i)->custom.callgrind.cumSamples / (float)summary;
                    (*iPr).called.at(i)->selfSeconds = (*iPr).called.at(i)->custom.callgrind.selfSamples / (float)summary;

//                     (*iPr).called.at(i)->custom.callgrind.selfSamples = (*iPr).called.at(i)->custom.callgrind.cumSamples / (*iPr).called.at(i)->calls;
                }
            }
        }
        for(int i=0; i< (*iPr).called.count(); ++i) {
            if ((*iPr).called.at(i)->calls != 0) {
                (*iPr).called.at(i)->custom.callgrind.selfSamples = (*iPr).called.at(i)->custom.callgrind.cumSamples / (*iPr).called.at(i)->calls;
            }
        }
    }
}

long long CParseProfile_callgrind::extractId(const QString& ln) {
    int posId;
    long long id;
    posId = ln.indexOf(QRegExp("(\\d+)"));
    if (posId == -1) {
        qDebug() << "id is wrong" << ln;
        return -1;
    }
    else {
        QString idStr = ln.mid(posId, ln.indexOf(")")-posId);
        id = idStr.toLongLong();
//         qDebug() << line << id;
    }
    return id;
}


void  CParseProfile_callgrind::cleanPointers(QVector<CProfileInfo>& workCProfile)
{
    CProfileInfo *p;
//     long int num;
    int pos;

    p = findFunction(workCProfile, actualFuncId);
    if (p == NULL)
        return;

//
//
    for(int i=0; i< p->called.count(); ++i) {
        for(int j=i+1; j< p->called.count(); ) {
            if (p->called[i] == p->called[j]) {
                p->numCalls[i] += p->numCalls[j];
                p->called.remove(j);
                p->numCalls.remove(j);
//                 j--;
            }
            else
                j++;
        }
    }
}

CProfileInfo* CParseProfile_callgrind::findFunction(QVector<CProfileInfo>& workCProfile, long int id)
{
    long int num;
//     CProfileInfo *p;

    for (num = 0; num < workCProfile.count(); ++num) {
        if (workCProfile[num].name == function[id]) {
            return &workCProfile[num];
        }
    }

    return NULL;
}

#if 0
bool CParseProfile_callgrind::buildGraph(CProfileInfo* p, bool prim)
{
    bool recFound = false;
    SCallGraphEntry *e = new SCallGraphEntry;

    e->line = linenr;
    e->recursive = false;

    e->primary = prim;

    e->name = p->name;
    // if we got a call graph block without a primary function name,
    // drop it completely.
    if (e->name == NULL || e->name.length() == 0) {
        delete e;
        return false;
    }

    if (prim == false) {
        for (int i=0; i< callGraphBlock.count(); i++) {
            if (p->name == callGraphBlock[i].name) {
                recFound = true;
                break;
            }
        }

        if (recFound == true) {
            callGraphBlock[0].recursive = true;
        }
    }

    callGraphBlock.append(*e);
    return true;
}
#endif

CProfileInfo* CParseProfile_callgrind::make_function(QVector<CProfileInfo>& workCProfile)
{
    CProfileInfo *p;
//     long int num;
    int pos;

// existiert?
    p = findFunction(workCProfile, actualFuncId);

    if (p != NULL) {
//         p->name = function[actualFuncId];
//         if (buildGraph(p, true) == false){
//             delete p;
//             return NULL;
//         }
        return p;
    }
//
    p = new CProfileInfo();// Function(id, name);
    QString fName = fileName[actualFileId];
    p->fileName = fName;

    QString lName = libName[actualLibId];
    if (lName.length() > 0) {
        p->libName = lName;
    }

    QString funN = function[actualFuncId];
    if (funN.length() == 0) {
        delete p;
        return NULL;
    }

    p->name = funN;
    p->called.clear();
    p->callers.clear();
    p->calls = 0;
    /*
        if (buildGraph(p, true) == false){
            delete p;
            return NULL;
        }*/

    pos = p->name.indexOf("::");

    if ( pos > 0) {
        p->object = p->name.left(pos);
        p->method = p->name.mid (pos + 2);
    }
    else
        p->method = p->name;


    workCProfile.append(*p);

    return p;
}



CProfileInfo* CParseProfile_callgrind::make_CalledFunction(QVector<CProfileInfo>& workCProfile)
{
    //FIXME: module and fileName are not being tracked reliably
    //id = "|".join((module, fileName, name))
    CProfileInfo *cf;
    CProfileInfo *f;
//     long int num;
    int pos;

    cf = findFunction(workCProfile, actualCalledFuncId);

    if (cf != NULL) { // exists
//         cf->name = function[actualCalledFuncId];

        f = findFunction(workCProfile, actualFuncId);


        if (f != NULL) {
            bool found = false;
            for (QVector<CProfileInfo*>::iterator ic = f->called.begin(); ic != f->called.end(); ++ic) {
                if ((*ic)->name == cf->name) {
//                     cf->recursive = true;
//                     beforePrimary = false;
                    found = true;
                    break;
                }
            }

//             if (beforePrimary) {
//                 if (f->callers.count() == 0 || f->callers.indexOf(cf) == -1) {
//                     f->callers.append (cf);
// //                     f->numCalls.append(0);
//                 }
//             } else {
//                 if (f->called.count() == 0 || f->called.indexOf(cf) == -1) {
//                     f->called.append ( cf);
// //                     f->numCalls.append(0);
//                 }
//             }
//             if (/*f->called.count() == 0 || */f->called.indexOf(cf) == -1){
//             if (found == false){
//                 f->called.append(cf);
//                     cf->callers.append(f);
//                 f->numCalls.append(0);
//             }
//
//             if (cf->callers.count() == 0 || cf->callers.indexOf(f) == -1) {
//                 cf->callers.append(f);
//             }
        }

        return cf;
    }

    cf = new CProfileInfo();// Function(id, name);

    QString fname = fileName[actualCalledFileId];
    cf->fileName =fname;
    cf->called.clear();
    cf->callers.clear();
    cf->numCalls.clear();

    QString lName = libName[actualCalledLibId];
    if (lName.length() > 0) {
        cf->libName = lName;
    }

    QString nFunc =function[actualCalledFuncId];
    if (nFunc.length() == 0) {
        delete cf;
        return NULL;
    }

    cf->name = nFunc;
//     if (buildGraph(p, false) == false){
//         delete p;
//         return NULL;
//     }

    pos = cf->name.indexOf("::");

    if ( pos > 0) {
        cf->object = cf->name.left(pos);
        cf->method = cf->name.mid (pos + 2);
    }
    else
        cf->method = cf->name;

    bool beforePrimary = true;

    f = findFunction(workCProfile, actualFuncId);
    if (f != NULL) {
        bool found = false;
        for (QVector<CProfileInfo*>::iterator ic = f->called.begin(); ic != f->called.end(); ++ic) {
            if ((*ic)->name == cf->name) {
                cf->recursive = true;
                beforePrimary = false;
                found = true;
                break;
            }
        }

        if (!beforePrimary) {
            if (f->callers.count() == 0 || f->callers.indexOf(cf) == -1) {
                f->callers.append (cf);
                f->numCalls.append(0);
            }
        } else {
            if (f->called.count() == 0 || f->called.indexOf(cf) == -1) {
                f->called.append ( cf);
                f->numCalls.append(0);
            }
        }

//         if (f->called.count() == 0 || f->called.indexOf(cf) == -1) {
//             f->called.append(cf);
//             f->numCalls.append(0);
//         }
//          if (cf->callers.count() == 0 || cf->callers.indexOf(f) == -1){
//             cf->callers.append(f);
//          }
    }

    workCProfile.append(*cf);

    return cf;
}


bool CParseProfile_callgrind::valid() const
{
    return mValid;
}

